//Способы превращения в строку:

//1. С помощью String

console.log(typeof(String(4)));

//2. С помощью конкатинации

console.log('' + 5);

//Пример использования конкатинации при формировании ссылки:

console.log('https:vk.com/catalog' + 5); //при передаче в адресную строку произойдет обращение к 5 каталогу

//Способы превращения в число

//1. С помощью Number

console.log(typeof(Number('5')));

//2. С помощью унарного плюса

console.log(+ '5');

//Логическое преобразование

//1. С помощью переменных

// 0, '', null, undefined, NaN всегда являются ложными. Если они являются изначальным значением переменной, а потом это значение меняется происходит преобразование

let switcher = null;

if(switcher) {
    console.log('Work')
}

switcher = 1;

if(switcher) {
    console.log('Work')
}

//2. С помощью Boolean

console.log(typeof(Boolean('5')));

//3. С помощью !!

console.log(!!'5');

//Способы общения с пользователем

alert() // - выводит модальное окно, в котором нужно нажать ОК

confirm() // - Предлагает пользователю подтвердить что-то нажав ок или отказаться нажав отмена

prompt() // - выводит модальное окно, со строкой, в которой пользователь может написать ответ на вопрос


// Строки


/*   В JavaScript любые текстовые данные являются строками. Не существует отдельного типа «символ», который есть в ряде других языков.

Символ	    Описание
\n	        Перевод строки
\r	        В текстовых файлах Windows для перевода строки используется комбинация символов \r\n, а на других ОС это просто \n. Это так по историческим причинам, ПО под Windows обычно понимает и просто \n.
\', \"	    Кавычки
\\	        Обратный слеш
\t	        Знак табуляции
\b, \f, \v	Backspace, Form Feed и Vertical Tab — оставлены для обратной совместимости, сейчас не используются.
\xXX	    Символ с шестнадцатеричным Юникодным кодом XX, например, '\x7A' — то же самое, что 'z'.
\uXXXX	    Символ в кодировке UTF-16 с шестнадцатеричным кодом XXXX, например, \u00A9 — Юникодное представление знака копирайта, ©. Код должен состоять ровно из 4 шестнадцатеричных цифр.
\u{X…XXXXXX} (от 1 до 6 шестнадцатеричных цифр)	Символ в кодировке UTF-32 с шестнадцатеричным кодом от U+0000 до U+10FFFF. Некоторые редкие символы кодируются двумя 16-битными словами и занимают 4 байта. Так можно вставлять символы с длинным кодом.

Все спецсимволы начинаются с обратного слеша, \ — так называемого «символа экранирования».

Он также используется, если необходимо вставить в строку кавычку.

К примеру:

alert( 'I\'m the Walrus!' ); // I'm the Walrus!






*/




// Функции

// Если функция объявлена только с ключевым словом function, ее можно вызывать даже до объявления, если же функция является значением переменной, то она вызывается только тогда когда будет прочитана в коде

/* 
Если нужно чтобы одна функция выполнилась позже другой, функция которая должна выполниться позже, задается в виде callback-функции

Пример:

function learnJs() {
    console.log('Я учу' + lang)
    calback()
}

learnJs('JavaScript', function(){
    console.log('Я прошел уже 3 урок')
})

В этом примере callback-функця выводит сообщение Я прошел уже 3 урок. Поэтому сначала будет выведено сообщение Я учу JavaScript, а тольпо потом сообщение callback-функции.

При этом саму callback функцию можно указать не внутри другой функции, а глобально, а потом просто вызывать в функции.

Пример:

function learnJs() {
    console.log('Я учу' + lang)
    calback()
}

function done() {
    console.log('Я прошел уже 3 урок')
}

learnJs('JavaScript', done)

В этом примере callback-функция done задана вне функции learnJs. При этом функция done передается в качестве одного из аргументов при вызове функции learnJs

*/

// Объекты

/* 
Для перебора свойств объекта используется цикл for in

Пример записи:

let options = {
    width: 1024,
    height: 768,
}

options.bool = false

options.styles = {
    border: grey,
    bg: yellow
}

for (let key in options) {
    console.log('Свойство ' + key + ' имеет значение ' + options[key].lenght)
}

В этом примере цикл for in перебирает все значения объекта options и выводит в консоль их значения


*/

// Массивы и псевдомассивы

/* 
Циклы for of и forEach используются для перебора значений массивов.

Пример:

let arr = [1, 2, 3, 4, 5, 6, 7]

arr.forEach(function(item, i, mass){
    console.log(i + ' : ' + item + mass)
})

При использовании цикла forEach ему в качестве аргумента передается callback-функция, которая в свою очередь содержит в качестве свойств содержит элемент массива, номер элемента в массиве и сам массив(можно указывать что-то одно)

Новым способом перебора массивов является цикл for of.

let arr = [1, 2, 3, 4, 5, 6, 7]

for(let key of arr) {
    console.log(key) - выведет в консоль значения масива
}

Если вместо for of использовать цикл for in, он покажет номера индексов в массиве

*/

// Получение элементов на странице.

/* 

document.getElementById('') - позволяет получить элемент с указанным id

document.getElementsByTagName('') - позволяет получить коллекцию элементов на странице,  имеющих одинаковые теги

document.getElementsByClassName('') - позволяет получить все элементы на странице, имеющие общий класс

document.querySelectorAll('') - позволяет получить все элементы, указав любое из их свойств (класс, тэг, id и т.д). При использовании этого метода перед документом, указанным в скобках нужно обязательно указать его принадлежность (поставить точку для класса, решетку для id и т.д)

document.querySelector('') - позволяет получить один элемент на странице, указав любое из его свойств (класс, тэг, id и т.д). При использовании этого метода перед документом, указанным в скобках нужно обязательно указать его принадлежность (поставить точку для класса, решетку для id и т.д)

При получении сразу нескольких элементов они формируют псевдомассив и чтобы обратиться к определенному элементу из списка, нужно указать его индекс, после названия переменной, содержащей псевдомассив.

Пример:

let box = document.getElementsByClassname('box') - теперь переменная box является псевдомассивом, который содержит в себе все элементы с классом box.

console.log(box[0]) - чтобы обратиться к первому элементу мы указываем его индекс после названия переменной, которая содержит псевдомассив

*/

//Действия с элементами на странице

/* 
После того как элемент найден с ним можно производить различные действия:

1. Изменение стилей

style позволяет изменить стили элемента используя JavaScript.

Пример:

box[1].style.backgroundColor = 'red' - меняет цвет выбранного элемента на красный.

Если нужно применить свойство ко всем элементам псевдомассива, это можно сделать с помщью цикла

Пример:

for(let i = 0; i < box.length; i++) {
    box[i].style.backgroundColor = 'green'
}

В этом примере благодаря подставлению i в box, при каждом выполнении цикла будет выполняться действие с новым элементом, а благодаря использованию box.length код сам поймет сколько раз выполнить цикл

При использовании для поиска элементов document.querySelector и document.querySelectorAll вместо цикла for можно использовать метод forEach

Пример:

box.forEach(function(item){ - item означает каждый элемент в массиве
    item.style.backgroundColor = 'white'
})


2. Создание элементов на странице

Для создания новых элементов на странице используется метод document.createElement('')

Пример:

let div = document.createElement('div') - создаст новый элемент div на странице

Для создания обычного текста без оболочки используется метод document.createTextNode('')

let text = document.createTextNode('Любой текст') - создаст на странице текст, указанный в скобках

Для стилизации созданных элементов к ним обычно добавляются классы, уже стилизовнные в css. Добавление происходит с помощью метода classList

div.classList.add('div-style')

Метод classList имеет свои методы. Например add добавляет класс, toggle позволяет менять класс в зависимости от определенных действий, remove позволяет удалить класс

Чтобы вставить созданный в JavaScript элемент в конец html-документа нужно воспользоваться методом appendChild()

document.body.appendChild(div) - созданный элемент появится в конце тега-родителя body.

Все методы, отвечающие за размещение элементов в html применяются только к родительским элементам

Пример:

let wrapper = document.querySelector('.wrapper')

wrapper.appendChild(div) - элемент появится в конце блока wrapper

Метод insertBefore помогает поместить элемент перед другими элементами внутри родителя. В качестве первого аргумента в метод передается элемент который нужно разместить, а в качестве второго аргумента элемент, перед которым он будет размещен. Если второй аргумент не будет указан, метод сработает также как и appendChild

Пример:

document.body.insertBefore(div, box[0]) - элемент div появится перед 1 элементом псевдомассива box

Метод removeChild удаляет выбранный элемент со страницы

Пример:

document.body.removeChild(box[2]) - со страницы удалится третий элемент псевдомассива box


Метод replaceChild позволяет заменить один элемент на другой. В этот метод в качестве первого аргумента передается элемент, который нужно поместитьна страницу, а в качестве второго аргумента. элемент, который будет заменен

document.body.replaceChild(div, box[1]) - элемент div заменит второй элемент в псевдомассиве box

Метод innerHTML позволяет добавлять элемент или текст в другие элементы. Метод применяется к тому элементу, внутри которого будет происходить размещение

Пример:

div.innerHTML = 'Текст' - текст который находится в кавычках появится внутри блока div

Внутри кавычек можно прописать не только текст, но и теги, например заголовок

div.innerHTML = '<h1>Текст</h1>'

Если текст, который нужно разместить внутри элемента, был получен от пользователя, можно использовать для его размещения метод textContent. Использование этого метода предотвратит возможный запуск вредоносных скриптов на странице.

div.textContent = 'Текст'


*/


// События и их обработчики

/* 
Обработчик события это функция которая запускается при наступлении определенного события

Метод addEventListener позволяет повешать несколько функций с разными дейтствиями на один элемент. В качестве первого аргумента в этот метод передается событие, которое должно произойти, а вторым аргументом передается функция, которая будет запускаться когда это событие произойдет

Пример: 

let btn = document.getElementsByTagName('button');

btn[0].addEventListener('click', function(){
    alert('Вы нажали первую кнопку');
})

btn[0].addEventListener('click', function(){
    alert('Вы нажали первую еще раз кнопку');
})

Объект event позволяет отследить какое событие и на каком элементе произошло на странице

Пример:

btn[0].addEventListener('click', function(e){
    console.log('Произошло событие: ' + e.type + ' на элементе ' + e.target)
});

В данном примере метод e.type покажет событие которое произошло на странице, а метод e.target покажет элемент, на котором оно произошло

Метод event.preventDefault позволяет отменить стандартное поведение элементов на странице(например переход по ссылке при клике)

Пример:

let link = document.querySelector('a');

link.addEventListener('click', function(e){
    e.preventDefault();
    console.log('Вы нажали на ссылку');
});

В этом примере, при отсутствии метода e.preventDefault(), при клике сразу произошле бы переход на целевую страницу, но благодаря этому методу мы отменили переход и теперь можем увидеть сообщение которое выведется в консоль при клике

Если нужно повесить обработчик событий на все элементы псевдомассива, необходимо использовать метод forEach

Пример:

btn.forEach(function(item){
    item.addEventListener('click', function(){
        console.log('Вы нажали на кнопку')
    })
})

Список событий:

События мыши:

click –  происходит, когда кликнули на элемент левой кнопкой мыши (на устройствах с сенсорными экранами оно происходит при касании).

contextmenu –  происходит, когда кликнули на элемент правой кнопкой мыши.

mouseover / mouseout –  когда мышь наводится на / покидает элемент.

mousedown / mouseup –  когда нажали / отжали кнопку мыши на элементе.

mousemove –  при движении мыши.


События на элементах управления:

submit – пользователь отправил форму <form>.

focus – пользователь фокусируется на элементе, например нажимает на <input>.


Клавиатурные события:

keydown и keyup – когда пользователь нажимает / отпускает клавишу.

События документа:

DOMContentLoaded – когда HTML загружен и обработан, DOM документа полностью построен и доступен.


CSS events:

transitionend – когда CSS-анимация завершена.





*/

//События на мобильных устройствах и основы регулярных выражений

/* 
Событие touchstart возникает на мобильном устройстве при совершении касания по какому-то элементу.

Событие touchmove возникает после касания элемента пальцем и перемещения пальца в сторону

Событие touchend возникает когда палец перестает касаться элемента

Событие touchenter возникает когда палец движется на экране и находит на какой-то элемент, когда палец покидает этот элемент происходит событие touchleave

Событие touchcancel возникает когда касание элемента перестает регистрироваться

Пример использования событий для мобильных устройств:

window.addEventListener('DOMContentLoaded', function(){
    let box = document.querySelector('.box');

    box.addEventListener('touchstart', function(e){
        e.preventDefault();
        console.log('This is box');
    });
});

Свойства объекта event для мобильных событий:

e.touches показывает количество пальцев, которые прикоснулись к экрану

e.changeTouches показывает все элементы, которых коснулись пальцы

e.targetTouches показывает элементы с которыми произошло взаимодействие

e.touches[индекс] покажет с каким объектом взаимодействовал палец под указанным индексом


*/

//Регулярные выражения

/* 
Регулярное выражение состоит из двух частей: паттерна и флага

Есть всего 3 флага в регулярных выражениях:

Флаг i говорит о том, что нужно найти что-то не учитывая регистр

Флаг g означает глобальность. Он позволяет найти все вхождения

Флаг m означает многострочность

Пример использования регулярного выражения:

let ans = prompt('Введите ваше имя')

let reg = /n/

console.log(ans.match(reg))

В данном примере мы с помощью метода match и регулярного выражения ищем в имени, введенном пользователем, букву n

Классы символов в регулярных выражениях:

1. Если нужно найти все цифры, используется \d

2. Если нужно найти все буквы, используется \w

3. Если нужно найти все пробелы используется \s

Пример:

let ans = prompt('Введите число')

let reg = /\d/g

console.log(ans.match(reg))

В данном примере будет выполнен поиск чисел во всей введенной строке

*/

//setTimeout и setInterval

/* 
Метод setTimeout() позволяет запустить функцию через указанный период времени. В качестве первого аргумента в метод передается функция, которую нужно запустить, а в качестве второго аргумента время в миллисекундах через которое нужно запустить функцию

Если работу метода нужно остановить применяется метод clearTimeout() в качестве аргумента которой нужно передать название таймера. Чтобы получить название таймера метод setTimeout можно присвоить в качестве значения для переменной

Пример:

let timerId = setTimeout(sayHi, 3000)

clearTmeout(timerId)

function sayHi() {
    alert('Hello World')
}

Метод setInterval позволяет запускать указанную функцию каждый раз через указанный пеотод времени. В качестве аргументов метод принимает те же значения что и setTimeout. И его остановка также производится с помщью clearTimeout

Делегирование событий позволяет запускать функцию для всех элементов, подходящих под определенные параметры (например имя тега). Делегирование задается для родительского элемента и действует на всех его потомков, даже на тех. которые появятся в будущем.

Пример:

let block = document.querySelector('.block')
let btn = document.getElementsByTagName('button')

block.addEventListener('click', function(e){
    if(e.target && e.target.tagName == 'BUTTON') {
        console.log('Hello World');
    }
});

В этом примере элемент block содержит в себе несколько кнопок. Мы вешаем на block событие, при котором клик на самого родителя никак не отображается, но при клике на кнопку внутри этого родителя мы выводим сообщение в консоль. Эти кнопки мы определяем благодаря объекту event и его методу target, который ищет кнопки по имени тега

*/

